package typegen

import (
	"fmt"
	"strings"
)

// generateCode generates Go code from an API schema.
func generateCode(schema *APISchema, pkgName string) string {
	var sb strings.Builder

	sb.WriteString("// Code generated by typegen. DO NOT EDIT.\n")
	fmt.Fprintf(&sb, "// Endpoint: %s\n", schema.Endpoint)
	fmt.Fprintf(&sb, "// Method: %s %s\n\n", schema.Method, schema.Path)
	fmt.Fprintf(&sb, "package %s\n\n", pkgName)

	needsTime := needsTimeImport(schema)
	needsJson := needsJsonImport(schema)

	if needsTime || needsJson {
		sb.WriteString("import (\n")
		if needsJson {
			sb.WriteString("\t\"encoding/json\"\n")
		}
		if needsTime {
			sb.WriteString("\t\"time\"\n")
		}
		sb.WriteString(")\n\n")
	}

	endpointName := sanitizeStructName(schema.Endpoint)
	nestedTypes := make(map[string][]Property)
	usedCommonTypes := make(map[string]bool)

	if len(schema.PathParams) > 0 {
		writeStructWithCommonTypes(&sb, endpointName+"PathParams", schema.PathParams, nestedTypes, endpointName, usedCommonTypes)
	}

	if schema.Request != nil && len(schema.Request.Properties) > 0 {
		writeStructWithCommonTypes(&sb, endpointName+"Request", schema.Request.Properties, nestedTypes, endpointName, usedCommonTypes)
	}

	// Always emit a response type since clientgen always references <Endpoint>Response.
	// Some endpoints legitimately have an empty response body.
	if schema.Response != nil && len(schema.Response.Properties) > 0 {
		writeStructWithCommonTypes(&sb, endpointName+"Response", schema.Response.Properties, nestedTypes, endpointName, usedCommonTypes)
	} else {
		fmt.Fprintf(&sb, "// %sResponse represents the API response for %s.\n", endpointName, schema.Endpoint)
		fmt.Fprintf(&sb, "type %sResponse struct {}\n\n", endpointName)
	}

	processed := make(map[string]bool)
	for len(nestedTypes) > 0 {
		var typeName string
		var props []Property
		for tn, p := range nestedTypes {
			if !processed[tn] {
				typeName = tn
				props = p
				break
			}
		}
		if typeName == "" {
			break
		}

		processed[typeName] = true

		if commonTypeName := matchCommonType(props); commonTypeName != "" {
			usedCommonTypes[commonTypeName] = true
		} else {
			writeStructWithCommonTypes(&sb, typeName, props, nestedTypes, typeName, usedCommonTypes)
		}
		delete(nestedTypes, typeName)
	}

	writeEnums(&sb, endpointName, schema)

	return sb.String()
}

// needsTimeImport checks if any field requires time.Time type.
func needsTimeImport(schema *APISchema) bool {
	if schema.Response != nil && len(schema.Response.Properties) > 0 {
		if !isPaginatedResponse(schema.Response.Properties) {
			if matchCommonType(schema.Response.Properties) != "" {
				hasTimeInOther := false
				for _, prop := range schema.PathParams {
					lowerName := strings.ToLower(prop.Name)
					if strings.HasSuffix(lowerName, "at") || strings.HasSuffix(lowerName, "_at") {
						hasTimeInOther = true
						break
					}
				}
				if schema.Request != nil {
					for _, prop := range flattenPropertiesSkipCommon(schema.Request.Properties) {
						lowerName := strings.ToLower(prop.Name)
						if strings.HasSuffix(lowerName, "at") || strings.HasSuffix(lowerName, "_at") {
							hasTimeInOther = true
							break
						}
					}
				}
				return hasTimeInOther
			}
		}
	}

	allProps := collectAllProperties(schema)
	for _, prop := range allProps {
		if len(prop.Children) > 0 {
			if matchCommonType(prop.Children) != "" {
				continue
			}
		}

		lowerName := strings.ToLower(prop.Name)
		if strings.HasSuffix(lowerName, "at") || strings.HasSuffix(lowerName, "_at") {
			return true
		}
	}
	return false
}

// needsJsonImport checks if any field requires json.RawMessage type.
func needsJsonImport(schema *APISchema) bool {
	if schema.Response != nil && len(schema.Response.Properties) > 0 {
		if !isPaginatedResponse(schema.Response.Properties) {
			if matchCommonType(schema.Response.Properties) != "" {
				return hasJsonRawMessageInProps(schema.PathParams) ||
					(schema.Request != nil && hasJsonRawMessageInProps(schema.Request.Properties))
			}
		}
	}

	allProps := collectAllProperties(schema)
	return hasJsonRawMessageInProps(allProps)
}

// hasJsonRawMessageInProps checks if any property would generate json.RawMessage.
func hasJsonRawMessageInProps(props []Property) bool {
	for _, prop := range props {
		if len(prop.Children) > 0 {
			if matchCommonType(prop.Children) != "" {
				continue
			}
			if hasJsonRawMessageInProps(prop.Children) {
				return true
			}
			continue
		}

		baseType := toGoType(prop.Type)
		if strings.Contains(baseType, "json.RawMessage") {
			return true
		}
	}
	return false
}

// collectAllProperties collects all properties from schema including nested ones.
func collectAllProperties(schema *APISchema) []Property {
	var all []Property
	all = append(all, schema.PathParams...)
	if schema.Request != nil {
		all = append(all, flattenPropertiesSkipCommon(schema.Request.Properties)...)
	}
	if schema.Response != nil {
		all = append(all, flattenPropertiesSkipCommon(schema.Response.Properties)...)
	}
	return all
}

// flattenPropertiesSkipCommon flattens properties but skips children of common types.
func flattenPropertiesSkipCommon(props []Property) []Property {
	var result []Property
	for _, p := range props {
		if isPaginatedResponse(props) && isPaginationField(p.Name) {
			continue
		}

		result = append(result, p)
		if len(p.Children) > 0 {
			if matchCommonType(p.Children) != "" {
				continue
			}
			result = append(result, flattenPropertiesSkipCommon(p.Children)...)
		}
	}
	return result
}

// writeStructWithCommonTypes writes a struct, using common types where applicable.
func writeStructWithCommonTypes(sb *strings.Builder, name string, props []Property, nestedTypes map[string][]Property, prefix string, usedCommonTypes map[string]bool) {
	// Check if this is a single-object response that matches a common type
	if strings.HasSuffix(name, "Response") && !isPaginatedResponse(props) {
		if commonTypeName := matchCommonType(props); commonTypeName != "" {
			usedCommonTypes[commonTypeName] = true
			fmt.Fprintf(sb, "// %s is an alias for %s.\n", name, commonTypeName)
			fmt.Fprintf(sb, "type %s = %s\n\n", name, commonTypeName)
			return
		}
	}

	comment := generateStructComment(name)
	fmt.Fprintf(sb, "// %s\n", comment)
	fmt.Fprintf(sb, "type %s struct {\n", name)

	if isPaginatedResponse(props) {
		usedCommonTypes["PaginatedResponse"] = true
		sb.WriteString("\tPaginatedResponse\n")
	}

	for _, prop := range props {
		if isPaginatedResponse(props) && isPaginationField(prop.Name) {
			continue
		}

		baseType := toGoType(prop.Type)
		goType := toGoTypeWithFieldName(baseType, prop.Name, prop.Required)
		fieldName := toPascalCase(prop.Name)
		jsonTag := prop.Name

		if len(prop.Children) > 0 {
			if commonTypeName := matchCommonType(prop.Children); commonTypeName != "" {
				usedCommonTypes[commonTypeName] = true
				if prop.IsArray {
					goType = "[]" + commonTypeName
				} else {
					goType = "*" + commonTypeName
				}
			} else {
				nestedTypeName := prefix + toPascalCase(prop.Name)
				if nestedTypes != nil {
					nestedTypes[nestedTypeName] = prop.Children
					collectNestedTypes(prop.Children, nestedTypes, nestedTypeName)
				}

				if prop.IsArray {
					goType = "[]" + nestedTypeName
				} else {
					goType = "*" + nestedTypeName
				}
			}
		} else if prop.IsArray {
			goType = "[]" + goType
		}

		if prop.Description != "" {
			desc := prop.Description
			if len(desc) > 80 {
				desc = desc[:77] + "..."
			}
			fmt.Fprintf(sb, "\t// %s\n", desc)
		}

		omitempty := ",omitempty"
		if prop.Required {
			omitempty = ""
		}
		fmt.Fprintf(sb, "\t%s %s `json:\"%s%s\"`\n", fieldName, goType, jsonTag, omitempty)
	}

	sb.WriteString("}\n\n")
}

// generateStructComment generates a meaningful comment based on struct name.
func generateStructComment(name string) string {
	if strings.HasSuffix(name, "PathParams") {
		endpoint := strings.TrimSuffix(name, "PathParams")
		return fmt.Sprintf("%s contains the path parameters for the %s endpoint.", name, endpoint)
	}

	if strings.HasSuffix(name, "Request") {
		endpoint := strings.TrimSuffix(name, "Request")
		return fmt.Sprintf("%s contains the request body for the %s endpoint.", name, endpoint)
	}

	if strings.HasSuffix(name, "Response") {
		endpoint := strings.TrimSuffix(name, "Response")
		return fmt.Sprintf("%s contains the response body from the %s endpoint.", name, endpoint)
	}

	return fmt.Sprintf("%s represents a nested object structure.", name)
}

// collectNestedTypes recursively collects nested types from properties.
func collectNestedTypes(props []Property, nestedTypes map[string][]Property, prefix string) {
	for _, prop := range props {
		if len(prop.Children) > 0 {
			nestedTypeName := prefix + toPascalCase(prop.Name)
			nestedTypes[nestedTypeName] = prop.Children
			collectNestedTypes(prop.Children, nestedTypes, nestedTypeName)
		}
	}
}

// writeEnums writes enum type definitions.
func writeEnums(sb *strings.Builder, prefix string, schema *APISchema) {
	var enumProps []Property
	if schema.Request != nil {
		for _, p := range schema.Request.Properties {
			if len(p.Enum) > 0 {
				enumProps = append(enumProps, p)
			}
		}
	}

	for _, prop := range enumProps {
		enumTypeName := prefix + toPascalCase(prop.Name)
		fmt.Fprintf(sb, "// %s represents the %s enum values.\n", enumTypeName, prop.Name)
		fmt.Fprintf(sb, "type %s string\n\n", enumTypeName)
		sb.WriteString("const (\n")
		for _, val := range prop.Enum {
			constName := enumTypeName + toEnumConstName(val)
			fmt.Fprintf(sb, "\t%s %s = \"%s\"\n", constName, enumTypeName, val)
		}
		sb.WriteString(")\n\n")
	}
}
